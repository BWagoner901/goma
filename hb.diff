diff --git a/include/mm_fill_stress.h b/include/mm_fill_stress.h
index 3229c57..e9b5b08 100644
--- a/include/mm_fill_stress.h
+++ b/include/mm_fill_stress.h
@@ -199,12 +199,13 @@ compute_d_exp_s_ds(dbl [DIM][DIM],                   //s - stress
                    dbl [DIM][DIM],                   // exp_s
                    dbl [DIM][DIM][DIM][DIM]);        // d_exp_s_ds
 
+dbl
+compute_deviatoric_tensor_norm_squared(const dbl [DIM][DIM]);
+
 void
 compute_saramito_model_terms(dbl*,                        // Saramito coefficient -- multiplies stress tensor
                              SARAMITO_DEPENDENCE_STRUCT*, // struct for sCoeff sensitvities
-                             dbl*,                        // viscosity computed from nexp and deviatoric stress norm
-                             dbl [DIM][DIM],              // visosity sensitvities to stress tensor components
                              const dbl [DIM][DIM],        // stress
-                             struct Generalized_Newtonian *gn_local );
+                             const struct Generalized_Newtonian*);
 
 #endif /* GOMA_MM_FILL_STRESS_H */
diff --git a/src/mm_fill_stress.c b/src/mm_fill_stress.c
index bfb7e19..9d03c47 100644
--- a/src/mm_fill_stress.c
+++ b/src/mm_fill_stress.c
@@ -1380,7 +1380,6 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
   int err;
   dbl alpha = 0;     /* This is the Geisekus mobility parameter */
   dbl lambda=0;    /* polymer relaxation constant */
-  dbl lambda0=0;   /* polymer relaxation constant value when mup = mup0 */
   dbl d_lambda_dF[MDE];
   double xi;
   double d_xi_dF[MDE];
@@ -1441,12 +1440,9 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
 
   /* polymer viscosity and derivatives */
   dbl mup;
-  dbl mup0;
   VISCOSITY_DEPENDENCE_STRUCT d_mup_struct;
   VISCOSITY_DEPENDENCE_STRUCT *d_mup = &d_mup_struct;
 
-  dbl d_mup_d_s[DIM][DIM];
-
   SARAMITO_DEPENDENCE_STRUCT d_saramito_struct;
   SARAMITO_DEPENDENCE_STRUCT *d_saramito = &d_saramito_struct;
 
@@ -1673,26 +1669,6 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
       
       /* get polymer viscosity */
       mup = viscosity(ve[mode]->gn, gamma, d_mup);
-	  mup0 = ve[mode]->gn->mu0;
-
-      if(saramitoEnabled == TRUE)
-	{
-    // This routine sets viscosity and its sensivity to stress in the case that nexp is nonzero.
-    // The 'viscosity' routine must always be called so that all other sensitivities are set.
-      compute_saramito_model_terms(&(saramitoCoeff), d_saramito, &(mup), d_mup_d_s, s, ve[mode]->gn);
-	}
-      else
-	{
-	  saramitoCoeff = 1.;
-	  d_saramito->tau_y = 0;
-			
-	  for(int i=0; i<VIM; ++i){
-	    for(int j=0; j<VIM; ++j){
-	      d_saramito->s[i][j] = 0;
-          d_mup_d_s[i][j] = 0;
-	    }
-	  }
-	}
 
       double d_alpha_dF[MDE];
       /* get Geisekus mobility parameter */
@@ -1710,8 +1686,7 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
       
       /* get time constant */
       if (ve[mode]->time_constModel == CONSTANT) {
-	lambda0 = ve[mode]->time_const;
-	lambda = lambda0*mup/mup0;
+	lambda = ve[mode]->time_const;
       } else if (ve[mode]->time_constModel == CARREAU || ve[mode]->time_constModel == POWER_LAW) {
 	lambda = mup/ve[mode]->time_const;
       } else if (ls != NULL && ve[mode]->time_constModel == VE_LEVEL_SET) {
@@ -1722,6 +1697,28 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
 	EH(err, "level_set_property() failed for polymer time constant.");
       }
 
+	// Note: if the Saramito model is enabled, all stress equation terms are normalized by
+	// the polymer viscosity so that
+	// lambda = 1/(elastic modulus)
+	// polymer viscosity = 1 [unitless]
+      if(saramitoEnabled == TRUE)
+	{
+	  lambda /= ve[mode]->gn->mu0;
+	  mup = 1.;
+	  compute_saramito_model_terms(&(saramitoCoeff), d_saramito, s, ve[mode]->gn);
+	}
+      else
+	{
+	  saramitoCoeff = 1.;
+	  d_saramito->tau_y = 0;
+			
+	  for(int i=0; i<VIM; ++i){
+	    for(int j=0; j<VIM; ++j){
+	      d_saramito->s[i][j] = 0;
+	    }
+	  }
+	}
+
       xi = 0;
       if (ve[mode]->xiModel == CONSTANT) {
 	xi = ve[mode]->xi;
@@ -2575,16 +2572,13 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
 				      pvar = upd->vp[pg->imtrx][var];
 				      for ( j=0; j<ei[pg->imtrx]->dof[var]; j++)
 					{
-					  const dbl d_lambda_d_s = lambda0/mup0*d_mup_d_s[p][q];
-
 					  phi_j = bf[var]->phi[j];
 					  mass = 0.;
 					  if ( pd->TimeIntegration != STEADY )
 					    {
 					      if ( pd->e[pg->imtrx][eqn] & T_MASS )
 						{
-						  mass = (1.+2.*tt) * phi_j/dt * (double)delta(a,p) * (double)delta(b,q)
-						       + d_lambda_d_s*s_dot[a][b]; 
+						  mass = (1.+2.*tt) * phi_j/dt * (double)delta(a,p) * (double)delta(b,q); 
 						  mass *= h3 * det_J;
 						  mass *= wt_func * at * lambda * wt * pd->etm[pg->imtrx][eqn][(LOG2_MASS)];
 						}
@@ -2609,15 +2603,6 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
 						  advection *=  h3 * det_J ;
 						  
 						  advection *= wt_func * wt * at * lambda * pd->etm[pg->imtrx][eqn][(LOG2_ADVECTION)];
-
-						  // compute lambda sensitivity term
-						  if(DOUBLE_NONZERO(d_lambda_d_s))
-						    {
-							  advection += ( lcwt*(s_dot_gt[a][b] + g_dot_s[a][b]) - ucwt*(gt_dot_s[a][b] + s_dot_g[a][b]) )
-							             * d_lambda_d_s * wt_func * at * det_J * wt * h3 
-										 * pd->etm[pg->imtrx][eqn][(LOG2_ADVECTION)];
-							                
-							}
 						}
 					    }
 					  
@@ -2645,7 +2630,7 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
 					      source_a *= saramitoCoeff;
 					      // sensitivities for saramito model:
                                               if (p <= q) {
-                                                source_a +=  d_saramito->s[p][q] * s[a][b] * Z - at * d_mup_d_s[p][q] * ( g[a][b] +  gt[a][b]);
+                                                source_a +=  d_saramito->s[p][q] * s[a][b] * Z;
                                               }
 		      			
 					      source_b  =0.;
@@ -2654,8 +2639,7 @@ assemble_stress_fortin(dbl tt,	/* parameter to vary time integration from
 						  source_b  = alpha * lambda * saramitoCoeff * 
 						    (s[q][b] * (double)delta(a,p) + s[a][p] * (double)delta(b,q))/mup; 
                                                   if (p <= q) {
-						    source_b += d_saramito->s[p][q] * alpha * lambda*( s_dot_s[a][b]/mup) 
-							         + saramitoCoeff * alpha * d_lambda_d_s *( s_dot_s[a][b]/mup); 
+						    source_b += d_saramito->s[p][q] * alpha * lambda*( s_dot_s[a][b]/mup);
                                                   }
 						}
 					      
@@ -6242,54 +6226,59 @@ compute_d_exp_s_ds(dbl s[DIM][DIM],                   //s - stress
 
 }
 /*****************************************************************************/
-void
-compute_saramito_model_terms(dbl *sCoeff,
-                             SARAMITO_DEPENDENCE_STRUCT *d_sCoeff,
-                             dbl* mu,
-                             dbl d_mu_d_s[DIM][Dim],
-                             const dbl stress[DIM][DIM],
-                             struct Generalized_Newtonian *gn_local) {
-  /* start by computing the norm of sigma_d (the deviatoric stress) which is written as
-   * sqrt( trace(sigma_d*sigma_d)/2 )
+  /* computes the square of the norm of the deviatoric part of a 2nd-degree tensor, s:
+   *  trace(s_d*s_d)/2 
    *
+   * where s_d is the deviatoric part of s.
    * see the following wikipedia page for the mathematical details:
    * https://en.wikipedia.org/wiki/Cauchy_stress_tensor#Invariants_of_the_stress_deviator_tensor
    */
-
-  const dbl yieldStress = gn_local->tau_y;
-  const dbl yieldExpon  = gn_local->fexp;
-  const dbl nInv        = 1./gn_local->nexp;
-  const dbl mu0         = gn_local->mu0;
-
-  const dbl epsilon = 1e-5;
-
+dbl
+compute_deviatoric_tensor_norm_squared(const dbl s[DIM][DIM]) {
   dbl traceOverVIM = 0;
   for (int i = 0; i < VIM; i++) {
-    traceOverVIM += stress[i][i];
+    traceOverVIM += s[i][i];
   }
 
   traceOverVIM /= VIM;
 
   // square of the deviatoric sress norm
-  dbl normOfStressDSqr = 0;
+  dbl result = 0;
   for (int i = 0; i < VIM; i++) {
-    normOfStressDSqr += pow(stress[i][i] - traceOverVIM, 2) / 2.;
+    result += SQUARE(s[i][i] - traceOverVIM) / 2.;
 
     for (int j = i + 1; j < VIM; j++) {
-      normOfStressDSqr += pow(stress[i][j], 2);
+      result += SQUARE(s[i][j]);
     }
   }
+  return result;
+}
 
-  const dbl normOfStressD = sqrt(normOfStressDSqr);
+// computes terms required for the Saramito EVP model
+void
+compute_saramito_model_terms(dbl *sCoeff,
+                             SARAMITO_DEPENDENCE_STRUCT *d_sCoeff,
+                             const dbl stress[DIM][DIM],
+                             const struct Generalized_Newtonian *gn_local) {
 
-  *mu = nInv == 1 ? mu0 : mu0 * pow(normOfStressD + epsilon, 1.-nInv);
+  const dbl yieldStress = gn_local->tau_y;
+  const dbl yieldExpon  = gn_local->fexp;
+  const dbl n           = gn_local->nexp;
+  const dbl m           = 1./n;
+  const dbl kInvPowM    = n == 1. ?  1./gn_local->mu0 : 1./pow(gn_local->mu0, m);
 
-  const dbl sc = 1. - yieldStress / normOfStressD;
 
-  //  phi  = Saramito coefficient with nexp = 1.
-  // This is useful for computing sensitivities 
-  dbl phi;
+
+  // square of the deviatoric sress norm
+  const dbl normOfStressDSqr = compute_deviatoric_tensor_norm_squared(stress);
+
+  const dbl normOfStressD = sqrt(normOfStressDSqr);
+
+  const dbl sc = n == 1 ? (1. - yieldStress / normOfStressD) 
+                        : (normOfStressD - yieldStress) / pow(normOfStressD, n);
+
   dbl expYSC = 1;
+  dbl phi;
   if (yieldExpon > 0) {
     expYSC = exp(sc / yieldExpon);
     phi = log(1. + expYSC) * yieldExpon;
@@ -6297,12 +6286,15 @@ compute_saramito_model_terms(dbl *sCoeff,
     phi = fmax(0, sc);
   }
 
-  *sCoeff = nInv == 1 ? phi : pow(phi, nInv);
+  *sCoeff = n == 1 
+          ? kInvPowM*phi 
+          : kInvPowM*pow(phi, m);
+
 
   // take care of indeterminate behavior for normOfStressD == 0
   if (normOfStressD == 0) {
     if (yieldStress <= 0) {
-      *sCoeff = 1;
+      *sCoeff = kInvPowM;
     } else {
       *sCoeff = 0;
     }
@@ -6310,27 +6302,40 @@ compute_saramito_model_terms(dbl *sCoeff,
 
   if (d_sCoeff != NULL) {
     // if normStress_d < yieldStress, set sensitivities to zero and return
-    if ((*sCoeff) == 0 || yieldStress <= 0) {
+    if ((sCoeff) == 0 || yieldStress <= 0) {
       for (int i = 0; i < VIM; i++) {
         for (int j = 0; j < VIM; j++) {
           d_sCoeff->s[i][j] = 0.;
-          d_mu_d_s[i][j] = 0.;
         }
       }
 
       d_sCoeff->tau_y = 0.;
     } else {
-      const dbl d_sCoeff_d_phi = nInv == 1 ? 1 : nInv * pow(phi, nInv-1);
       // otherwise, sensitivities need to be calculated
-      d_sCoeff->tau_y = -d_sCoeff_d_phi / (normOfStressD);
-      dbl d_sCoeff_d_normOfStressD = d_sCoeff_d_phi * yieldStress / (normOfStressDSqr);
+	  dbl d_sCoeff_d_normOfStressD;
+	  if(n == 1){
+        d_sCoeff->tau_y          = -kInvPowM/(normOfStressD);
+		d_sCoeff_d_normOfStressD = kInvPowM*yieldStress/(normOfStressDSqr);
+	  }
+	  else{
+      d_sCoeff->tau_y          = -kInvPowM*m*pow(normOfStressD - yieldStress, m-1.)/normOfStressD;
+      d_sCoeff_d_normOfStressD = *sCoeff*((m-1)*normOfStressD + yieldStress)
+	                                    /((normOfStressD - yieldStress)*normOfStressD);
+	  }
       if (yieldExpon > 0) {
         const dbl expYSCDerivativeTerm = expYSC / (1 + expYSC);
         d_sCoeff->tau_y *= expYSCDerivativeTerm;
         d_sCoeff_d_normOfStressD *= expYSCDerivativeTerm;
       }
 
-      // fill d_sCoeff->s[i][j] with d(normOfStressDSqr)/d(stress[i][j])
+      dbl traceOverVIM = 0;
+      for (int i = 0; i < VIM; i++) {
+        traceOverVIM += stress[i][i];
+      }
+    
+      traceOverVIM /= VIM;
+
+	  // fill d_sCoeff->s[i][j] with d(normOfStressDSqr)/d(stress[i][j])
       for (int i = 0; i < VIM; i++) {
         d_sCoeff->s[i][i] = -traceOverVIM;
 
@@ -6351,28 +6356,7 @@ compute_saramito_model_terms(dbl *sCoeff,
        *                      =   d(sCoeff)/d(normOfStressD)
        *                        * 0.5/normOfStressD
        *                        * d(normOfStressDSqr)/d(stress)
-       * 
-       * A similar procedure is used to compute viscosity sensitivities to stress
        */
-      if (nInv == 1){
-        for (int i = 0; i < VIM; i++) {
-          for (int j = i; j < VIM; j++) {
-            d_mu_d_s[i][j] = 0.;
-          }
-        }
-      } else {
-        for (int i = 0; i < VIM; i++) {
-          for (int j = i; j < VIM; j++) {
-            /* d(mu)/d(stress) =   d(mu)/d(normOfStressD)
-                                 * d(normOfStressD)/d(normOfStressDSqr)
-                                 * d(normOfStressDSqr)/d(stress)
-            */
-            d_mu_d_s[i][j] = mu0 * (1.-nInv) * pow(normOfStressD + epsilon, -nInv) 
-                           * 0.5 / normOfStressD 
-                           * d_sCoeff->s[i][j];
-          }
-        }
-      }
 
       dbl d_normOfStressD_d_Stress = 0.5 / normOfStressD * d_sCoeff_d_normOfStressD;
 
diff --git a/src/mm_ns_bc.c b/src/mm_ns_bc.c
index 73aedb3..de5c31b 100644
--- a/src/mm_ns_bc.c
+++ b/src/mm_ns_bc.c
@@ -7393,8 +7393,6 @@ stress_no_v_dot_gradS(double func[MAX_MODES][6],
   VISCOSITY_DEPENDENCE_STRUCT *d_mup = &d_mup_struct;
   dbl d_mup_dv_pj;
 
-  dbl d_mup_d_s[DIM][DIM];
-
   dbl saramitoCoeff;
   SARAMITO_DEPENDENCE_STRUCT d_saramito_struct;
   SARAMITO_DEPENDENCE_STRUCT *d_saramito = &d_saramito_struct;
@@ -7545,9 +7543,7 @@ stress_no_v_dot_gradS(double func[MAX_MODES][6],
 
       if(saramitoEnabled == TRUE)
 	{
-    // This routine sets viscosity and its sensivity to stress in the case that nexp is nonzero.
-    // The 'viscosity' routine must always be called so that all other sensitivities are set.
-    compute_saramito_model_terms(&(saramitoCoeff), d_saramito, &(mup), d_mup_d_s, s, ve[mode]->gn);
+	  compute_saramito_model_terms(&(saramitoCoeff), d_saramito, s, ve[mode]->gn);
 	}
       else
 	{
@@ -7557,7 +7553,6 @@ stress_no_v_dot_gradS(double func[MAX_MODES][6],
 	  for(int i=0; i<VIM; ++i){
 	    for(int j=0; j<VIM; ++j){
 	      d_saramito->s[i][j] = 0;
-        d_mup_d_s[i][j] = 0;
 	    }
 	  }
 	}
@@ -7892,7 +7887,7 @@ stress_no_v_dot_gradS(double func[MAX_MODES][6],
                                      source = saramitoCoeff * Z * phi_j * (double)delta(a,p) * (double)delta(b,q);
                                      if( p == q)  source +=  s[a][b] * dZ_dtrace * phi_j;
                                      if (p <= q) {
-                                       source += phi_j * (d_saramito->s[p][q] * Z * s[a][b]- at * d_mup_d_s[p][q] * ( g[a][b] +  gt[a][b]));
+                                       source += phi_j * d_saramito->s[p][q] * Z * s[a][b];
                                      }
 
                                      if (alpha != 0.)
diff --git a/src/mm_post_proc.c b/src/mm_post_proc.c
index cd53770..b18c540 100644
--- a/src/mm_post_proc.c
+++ b/src/mm_post_proc.c
@@ -2509,7 +2509,7 @@ calc_standard_fields(double **post_proc_vect, /* rhs vector now called
   {  
     for (int mode = 0; mode < vn->modes; mode++) {
       dbl coeff;
-      compute_saramito_model_terms(&(coeff), NULL, &(mup), NULL, fv->S[mode], ve[mode]->gn);
+      compute_saramito_model_terms(&(coeff), NULL, fv->S[mode], ve[mode]->gn);
       local_post[SARAMITO_YIELD + mode] = coeff;
       local_lumped[SARAMITO_YIELD + mode] = 1.;
     }
